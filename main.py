#Main program for Project 1 - Algorithms class
import tkinter as tk
from tkinter import *
import csv
import time
import sys
import pandas as pd
import numpy as np
import subprocess
#Application class definition (Tk frame for graphics.)
class Application(tk.Frame):
    #Initialization of the class and subsequently GUI.
    def __init__(self, master=None):
        super().__init__(master)
        self.master = master
        self.pack()
        self.create_window()
    #Window creation method.
    def create_window(self):
        self.window = tk
        #Sort dataset for selection in the GUI
        sorts = [("Selection Sort","selectionSort"), ("Bubble Sort","bubbleSort"), ("Insertion Sort","insertionSort"), ("Merge Sort","mergeSort"), ("Quick Sort","quickSort")]
        #File dataset for selection in the GUI. Files generated by the PRNG are saved as CSV for easier parsing.
        files = [(5000, "5000.csv"), (25000, "25000.csv"), (80000, "80000.csv"), (150000, "150000.csv"), (300000, "300000.csv")]

        #Setting vars for selections
        v = StringVar()
        v.set("selectionSort")
        f = StringVar()
        f.set("5000.csv")
        
        r = IntVar()
        r.set(1)
        
        
        count = 0
        self.label = tk.Label(self)
        self.label["text"] = "Select sorting algorithm:"
        self.label.pack(side=TOP)

        #Creation of radiobuttons
        for item, method in sorts:
            b = Radiobutton(self, text=item,
                        variable=v, value=method)
            b.pack(anchor=W, side=TOP)

        self.label1 = tk.Label(self)
        self.label1["text"] = "Select input size:"
        self.label1.pack(side=TOP)

        #Creation of radiobuttons
        for item, n in files:
            b = Radiobutton(self, text=item,
                        variable=f, value=n)
            b.pack(anchor=W, side=TOP)
            count +=1
            self.button = tk.Button(self)
            
        self.label2 = tk.Label(self)
        self.label2["text"] = "Number of runs: "
        self.label2.pack(side=TOP)

        self.runs = tk.Spinbox(self, from_=1, to=10, textvariable=r)
        self.runs.pack(side=TOP)

        self.button1 = tk.Button(self)
        self.button1["text"] = "Start"
        self.button1["command"] = lambda: route(self,v.get(),f.get(), r.get())
        self.button1.pack(side=TOP)

        #Allow to quit.
        self.quit = tk.Button(self, text="QUIT", fg="red", command=self.master.destroy)
        self.quit.pack(side=BOTTOM)



        #Main router method to call the algorithm to use.
        def route(self, algorithm, file, runs):
            fileL = []
            #Open file and parse info.
            with open('{}'.format(file)) as csv_file:
                reader = csv.reader(csv_file, delimiter=',')
                fileL = list(reader)
            fileLi = fileL[0]
            #Convert the info to Int from String
            fileList = [int(x) for x in fileLi]
            
            ##
            ## Selection of algorithm with timer start and end. 
            ## Timer starts before method is called and ends after method returns valid output.
            ##
            
            if algorithm == "selectionSort":

                times = []
                fil = fileList[:]
                start = time.time()
                selectionSort(self,fil)
                end = time.time()
                print(end-start)
                
                for i in range(0, runs):
                    #COPY BY VALUE NOT REFERENCE
                    files = fileList[:]
                    start = time.time()
                    selectionSort(self,files)
                    end = time.time()
                    times.append(end-start)
                for t in times:
                    print("Selection Sort {}, time elapsed: {} s".format(file, t))
                

                return times
                
            elif algorithm == "bubbleSort":
                times = []
                fil = fileList[:]
                start = time.time()
                bubbleSort(self,fil)
                end = time.time()
                print(end-start)
            
                for i in range(0, runs):
                    #COPY BY VALUE NOT REFERENCE
                    files = np.array(fileList[:])
                    start = time.time()
                    bubbleSort(self,files)
                    end = time.time()
                    times.append(end-start)
                for t in times:
                    print("Bubble Sort {}, time elapsed: {} s".format(file, t))
                
                return times
                
            elif algorithm == "insertionSort":

                times = []
                
                fil = fileList[:]
                start = time.time()
                insertionSort(self,fil)
                end = time.time()
                print(end-start)

                for i in range(0, runs):
                    #COPY BY VALUE NOT REFERENCE
                    files = np.array(fileList[:])
                    start = time.time()
                    insertionSort(self,files)
                    end = time.time()
                    times.append(end-start)

                for t in times:
                    print("Insertion Sort {}, time elapsed: {} s".format(file, t))

                return times
                
            elif algorithm == "mergeSort":

                times = []
                for i in range(0, runs):
                    #COPY BY VALUE NOT REFERENCE
                    files = np.array(fileList[:])
                    start = time.time()
                    mergeSort(self,files)
                    end = time.time()
                    times.append(end-start)
               
                for t in times:
                    print("Merge Sort {}, time elapsed: {} s".format(file, t))

                return times
        
            elif algorithm == "quickSort":

                times = []
                for i in range(0, runs):
                    #COPY BY VALUE NOT REFERENCE
                    files = fileList[:]
                    start = time.time()
                    quickSort(self, files, 0, len(files)-1)
                    end = time.time()
                    times.append(end-start)
                    
                for t in times:
                    print("Quick Sort {}, time elapsed: {} s".format(file, t))
                return times
                
            '''
            SelectionSort Implementation 
            O(n^2) - In
            '''
        def selectionSort(self, array):
            n = len(array)
            #Loop through array and subarray.
            for i in range(0,n-1):
                min = i
                for j in range(i+1, n):
                    #Comparison 
                    if array[j] < array[min]:
                        min = j
                #Swap in place.
                array[i], array[min] = array[min], array[i]
            return array

        '''
            BubbleSort
            O(N^2) - In Place
        '''
        def bubbleSort(self, array):
            n = len(array)


            ## GO through all elements
            for i in range(0, n-1):
                for j in range(0, n-i-1):
                    #swap
                    if array[j] > array[j+1]:
                        array[j], array[j+1] = array[j+1], array[j]
            return array

        '''
            InsertionSort
            O(N^2) - In Place
        '''
        def insertionSort(self, array):
            n = len(array)

            for i in range(1, n):
                current = array[i]
                j = i-1
                while j >= 0 and current < array[j]:
                    array[j+1] = array[j]
                    j -= 1
                array[j+1] = current
            return array

        '''
            MergeSort
            O(nlogn) - Division of arrays
        '''
        def mergeSort(self, arr): 
            if len(arr) >1: 
                mid = len(arr)//2 # Finding the mid of the array 
                L = arr[:mid] # Dividing the array elements  
                R = arr[mid:] # into 2 halves 
          
                mergeSort(self, L) # Sorting the first half 
                mergeSort(self, R) # Sorting the second half 
          
                i = j = k = 0
                  
                # Copy data to temp arrays L[] and R[] 
                while i < len(L) and j < len(R): 
                    if L[i] < R[j]: 
                        arr[k] = L[i] 
                        i+= 1
                    else: 
                        arr[k] = R[j] 
                        j+= 1
                    k+= 1
                  
                # Checking if any element was left 
                while i < len(L): 
                    arr[k] = L[i] 
                    i+= 1
                    k+= 1
                  
                while j < len(R): 
                    arr[k] = R[j] 
                    j+= 1
                    k+= 1
            return arr

        '''
            QUICKSORT
            O(nlogn) - In Place
        '''

        def partition(array, start, end):
            pivot = array[start]
            low = start + 1
            high = end

            while True:
                # If the current value we're looking at is larger than the pivot
                # it's in the right place (right side of pivot) and we can move left,
                # to the next element.
                # We also need to make sure we haven't surpassed the low pointer, since that
                # indicates we have already moved all the elements to their correct side of the pivot
                while low <= high and array[high] >= pivot:
                    high = high - 1

                # Opposite process of the one above
                while low <= high and array[low] <= pivot:
                    low = low + 1

                # We either found a value for both high and low that is out of order
                # or low is higher than high, in which case we exit the loop
                if low <= high:
                    array[low], array[high] = array[high], array[low]
                    # The loop continues
                else:
                    # We exit out of the loop
                    break

            array[start], array[high] = array[high], array[start]

            return high

        def quickSort(self, array, start, end):
            sys.setrecursionlimit(len(array)+30000)
            if start >= end:
                return

            p = partition(array, start, end)
            quickSort(self, array, start, p-1)
            quickSort(self, array, p+1, end)
            return array

root = tk.Tk()
app = Application(master=root)
app.mainloop()
